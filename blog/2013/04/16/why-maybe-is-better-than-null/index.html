<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
    <head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
        <meta name="description" content="Maybe, at its core, is a construct that allows programmers to move null checks into the type system, so they can be enforced at compile-time.">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:url" content="http://nickknowlson.com/blog/2013/04/16/why-maybe-is-better-than-null/">
        <meta name="twitter:title" content="The Definitive Reference To Why Maybe Is Better Than Null">
        <meta name="twitter:description" content="Maybe, at its core, is a construct that allows programmers to move null checks into the type system, so they can be enforced at compile-time.">
        <meta name="twitter:image" content="http://nickknowlson.com/img/logos/logox50.png">
        <meta name="twitter:site" content="@nickknw">

        <meta property="og:title" content="The Definitive Reference To Why Maybe Is Better Than Null" >
        <meta property="og:type" content="article" >
        <meta property="og:image" content="http://nickknowlson.com/img/logos/logox200.png" >
        <meta property="og:url" content="http://nickknowlson.com/blog/2013/04/16/why-maybe-is-better-than-null/">
        <meta property="og:site_name" content="Nick Knowlson dot com">
        <meta property="og:description" content="Maybe, at its core, is a construct that allows programmers to move null checks into the type system, so they can be enforced at compile-time.">
        <meta property="fb:admins" content="717055264" />

        <title>The Definitive Reference To Why Maybe Is Better Than Null - Nick Knowlson</title>

        <link rel="stylesheet" type="text/css" href="/css/site.css" >
        <link rel="stylesheet" type="text/css" href="/css/syntax.css" >
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon-precomposed" href="/favicon.ico" >
        <link href="http://feeds.feedburner.com/NickKnowlson" type="application/atom+xml" rel="alternate" title="Blog ATOM Feed" />
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js" type="text/javascript"></script>
        <script type="text/javascript">
        if (typeof jQuery == 'undefined')
        {
            document.write(decodeURIComponent("%3Cscript src='/js/jquery-1.6.1.min.js' type='text/javascript'%3E%3C/script%3E"));
        }
        </script>
        

        
        <script type="text/javascript">
        // TODO: convert to css hover sometime
        $(document).ready(function () {
            $("#rss-nav-icon img").hover(function () {
                $(this).attr("src","/img/rss-icon-lit.png");
            }, function() {
                $(this).attr("src","/img/rss-icon-dim.png");
            });
            $("#twitter-nav-icon img").hover(function () {
                $(this).attr("src","/img/twitter-icon-lit.png");
            }, function() {
                $(this).attr("src","/img/twitter-icon-dim.png");
            });
        });
        </script>

        <!-- Google Analytics -->
        <script type="text/javascript">
          var _gaq = _gaq || [];

          if (document.location.hostname !== "localhost") {
              _gaq.push(['_setAccount', 'UA-24781362-1']);
              _gaq.push(['_trackPageview']);

              (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
              })();
          }
        </script>
    </head>
    <body>
	<div id="header" class="grid grid-16">
            <a href="/"><img src="/img/logos/logo6.png" alt="logo" /></a>
            <ul id="nav">
                <li><a class=" nav-link" href="/">Home</a></li>
                <li><a class=" nav-link" href="/about/">About</a></li>
                <li><a class=" nav-link" href="/projects/">Projects</a></li>
                <li><a class="selected nav-link" href="/blog/">Blog</a></li>
                <li><a class=" nav-link" href="/contact/">Contact</a></li>
                <li><a id="rss-nav-icon" href="http://feeds.feedburner.com/NickKnowlson"><img src="/img/rss-icon-dim.png" alt="link to feedburner rss" /></a></li>
                <li><a id="twitter-nav-icon" href="http://twitter.com/#!/nickknw"><img src="/img/twitter-icon-dim.png" alt="link to twitter" /></a></li>
            </ul>
	</div>

        <div id="content" class="grid grid-16" style="background-color:white; clear:both;">
            <div id="content-padding">
                <a href="/blog/archive/">&laquo; Back to posts</a>
<h1 style="margin:0px;;">The Definitive Reference To Why Maybe Is Better Than Null</h1>
<div class="faded" style="font-size:14px; margin-bottom:5px;">16 Apr 2013</div>
<div id="post">
<p>This article is divided into two parts: <a href='#explanation'>Explanation</a> and <a href='#faq'>FAQ</a>. The explanation shows the reasons why a bunch of people think Maybe is way more useful than <code>null</code>. The FAQ is a list of my responses to common arguments I&#8217;ve seen about the shortcomings of Maybe.</p>

<p>I&#8217;m going to try to not go overboard with details here - my aim is to make it accessible to as many programmers as possible, not to be as thorough as possible.</p>
<h2 id='explanation'>Explanation</h2><h3>Motivation</h3>
<p>Tony Hoare, the inventor of <code>null</code>, <a href='http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake'>has gone on record calling it his &#8216;billion-dollar mistake&#8217;</a>. So what should replace it?</p>

<p>Maybe, at its core, is a construct that allows programmers to <strong>move null checks into the type system</strong>, so they can be enforced at <em>compile-time</em>. Instead of forgetting to deal with a null check and finding out with an exception at run-time, you forget to deal with a null check and <em>find out with an error at compile-time,</em> before anyone else even sees it! And that&#8217;s <strong>not just some</strong> null checks, that&#8217;s <strong>all of them!</strong></p>
<h3>Details</h3>
<p>There are two components to an environment free of null pointer exceptions:</p>

<ol>
<li>The elimination of <code>null</code>. This means that all types (even reference types!) become non-nullable.</li>

<li>An alternative representation for the idea of &#8220;may contain an empty or invalid value&#8221;. This is what Maybe is for.</li>
</ol>

<p>So how does Maybe accomplish this, and how does it achieve all those benefits listed above? It&#8217;s actually very straightforward.</p>

<p>I&#8217;m going to explain this in object-oriented terms, because if you&#8217;re already familiar with algebraic data types odds are you already know about Maybe too. Anyway, think of <code>Maybe&lt;T&gt;</code> as an interface with a single type parameter that has exactly two implementing classes: <code>Just&lt;T&gt;</code> and <code>Nothing</code>. The <code>Just&lt;T&gt;</code> class wraps a value of some other type and the <code>Nothing</code> class doesn&#8217;t. There are a variety of methods provided by Maybe to extract the value safely, but I&#8217;m going to omit these for now, as they&#8217;re not the point. When you receive an object of type <code>Maybe&lt;String&gt;</code> (for example) you now have the type system helping you out, telling you &#8220;there <em>might</em> be a String here but it <em>might</em> be empty&#8221;. You <strong>can&#8217;t</strong> perform operations on the String until you&#8217;ve safely extracted it and <em>made a choice</em> about what to do in the case that its empty.</p>

<p>By itself (without point <strong>#1</strong>) this is nice but not fantastic. The benefit really kicks in when you also have non-nullable types. It simplifies the 80% of the cases that don&#8217;t involve <code>null</code> and gives significance and meaning to the times when you do deal with objects wrapped in <code>Maybe&lt;T&gt;</code>. It lets you say both <strong>&#8220;I know that this value will <em>literally never</em> be null&#8221;</strong> and <strong>&#8220;It is immediately obvious to me that I need to handle the case of an empty value here&#8221;</strong>.</p>
<h3>Conclusion</h3>
<p>It&#8217;s not that dealing with any given instance of null is particularly hard, it&#8217;s that it is <a href='http://james-iry.blogspot.ca/2013/03/king-null-stubborn.html'>so easy to miss one</a>. Removing this concern and encoding the information in the type system means programmers have less things to keep track of and simplifies control flow across the entire program. Like with memory management: when you don&#8217;t have to keep track of it manually it is just plain easier to write code. More importantly, it is easier to write <strong>more robust</strong> code. For all programmers, not just the experienced or talented.</p>

<p>And that is something I am firmly in favour of. A product is never the result of a single person&#8217;s code - everything has dependencies. Improvements to other people&#8217;s code benefit all of us.</p>
<h3>Addendum</h3>
<p>There are two more points I&#8217;d like to address about Maybe that are separate from actually explaining why it is useful.</p>

<p><strong>First</strong>, I&#8217;ve been a bit inaccurate on purpose when just referring to this idea as Maybe. There is an implementation of this idea in Haskell called Maybe, but implementations in different languages have different names.</p>

<ul>
<li>ML, Scala, F#, Rust: Option</li>

<li>Fantom, Kotlin: ? appended to type</li>

<li>C#: Nullable or ? appended to type</li>
</ul>

<p><strong>Second</strong>, not all languages with Maybe have non-nullable types. This makes Maybe less valuable in those environments (since you lose the <strong>very</strong> useful &#8220;I know this value will never contain <code>null</code>&#8221; guarantee&#8221;) and ends up confusing people who are skeptical of Maybe&#8217;s benefits.</p>

<p>To help clarify this: I agree that in a language where you don&#8217;t have the guarantee provided by non-nullable types, Maybe <em>just isn&#8217;t as useful</em>. But it is not use<i>less</i> either and depending on the environment may still provide some benefit.</p>
<h2 id='faq'>FAQ</h2>
<p>Posts like these are tricky. To explain something understandably and (relatively) concisely I can&#8217;t qualify every statement and address all the holes inline. Here is where I&#8217;ll address the bits I skipped as well as some common sentiments I&#8217;ve previously seen on this topic.</p>

<p>I have made each headline a link as well so each question/answer combo can be linked to individually.</p>

<ol>
<li><a href='#maybe-shortcomings'>Maybe isn&#8217;t the be-all end-all.</a></li>

<li><a href='#ide-plugin'>My IDE plugin already does this.</a></li>

<li><a href='#hiding'>NPEs are the proper response to a missing value you forgot to consider.</a></li>

<li><a href='#real-problem'>The real problem is people not properly reasoning about their functions.</a></li>

<li><a href='#default-value'>What if a value cannot have any meaningful default value?</a></li>

<li><a href='#same-thing'>So you&#8217;re still testing against null, except that it&#8217;s called Nothing.</a></li>

<li><a href='#safe-navigation'>I think the safe navigation operator in Groovy etc. is better than Maybe.</a></li>

<li><a href='#fantom-kotlin'>What about Fantom &#38; Kotlin?</a></li>

<li><a href='#option-scala'>But Option in Scala DOESN&#8217;T save you from null!</a></li>

<li><a href='#unsafe-methods'>Safety ISN&#8217;T guaranteed because of the existence of unsafe extraction methods.</a></li>

<li><a href='#overhead'>Using Maybe is not worth the overhead.</a></li>

<li><a href='#examples'>Enough vague, high-level information. Show me some examples!</a></li>
</ol>
<h4><a class='header_link' href='#maybe-shortcomings' id='maybe-shortcomings'>Maybe isn't the be-all
end-all.</a> </h4>
<p>I definitely agree. For one thing, I haven&#8217;t even mentioned <a href='http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Either.html'>Either</a>! This article is for people who aren&#8217;t even convinced of the benefits of Maybe yet. In order to get my point across effectively I want to avoid overwhelming the reader with information, so I restricted the topics brought up here.</p>

<p>If you want a higher level perspective on this issue, take a look at <a href='http://lambda-the-ultimate.org/node/3186#comment-46637'>dmbarbour&#8217;s view:</a></p>
<blockquote>
<p>There are two mistakes. One mistake is providing a 'sum' type (eqv. to Just
Object | Nothing) without recognition of the typechecker. The other mistake
is joining this sum type at the hip with the idea of references, such that
you cannot have one without the other.</p>

<p>These mistakes may, and I suspect should, be resolved independently.
Thinking there's just one mistake, and thus just one language feature to
solve it, might very well be a third mistake.</p>
</blockquote>
<p>Beautifully stated! This is a much more general (and elegant) way to look at it. It&#8217;s a somewhat harder sentiment to communicate effectively to a lot of people though.</p>
<h4><a class='header_link' href='#ide-plugin' id='ide-plugin'>My IDE plugin already does this.</a> </h4>
<p>Yes, there are some IDEs and plugins that provide limited null reference analysis. The key though, is that it <strong>is</strong> limited. As far as I know (and I&#8217;ve looked) none of them provide the same system-wide elimination of <code>null</code> that encoding it in the type-system can guarantee.</p>

<p>And so, you still don&#8217;t get the same reassurances of &#8220;I know this value will <em>literally never</em> be null&#8221; and &#8220;It is immediately obvious that I have to handle the case of an empty value here&#8221;.</p>
<h4><a class='header_link' href='#hiding' id='hiding'>NPEs are the proper
response to a missing value you forgot to consider. You should be notified when
something goes wrong, not hide it with Maybe.</a> </h4>
<p>I&#8217;ve got good news for you - we fundamentally agree in our approach to how errors should be handled! You might have seen some bad examples of Maybe usage, since proper usage would lead to these errors being caught <em>even earlier</em> than a NullPointerException would have.</p>

<p>You can still choose to do the equivalent of <code>if (null) return;</code> and some examples <em>will do that</em>, because it makes sense to do in some contexts. What matters is that Maybe forces you to think about it at the time of <em>writing</em> the code, and to be <em>explicit</em> about it.</p>

<p>Instead of you being notified when things go wrong, Maybe forces you to <strong>think things through</strong> in the first place and make an explicit choice about what to do (at least as far as possibly empty values are concerned).</p>

<p>And finally, for those of you who really love exceptions, implementations of Maybe usually provide an unsafe retrieval method, so you can replicate the behaviour of null (run-time exceptions and all) <em>if</em> that is what you <em>choose</em> to do.</p>
<h4><a class='header_link' href='#real-problem' id='real-problem'>The real
problem is people not properly reasoning about their functions, that isn't the
fault of null.</a> </h4>
<p>Sure, that is one way to look at it: it&#8217;s not <code>null</code>&#8217;s fault, it is the programmer&#8217;s fault. If you take this view then <code>null</code> is just one of the tools used to represent emptiness and invalid values. But it isn&#8217;t a very good tool, or at least not as good as it could be.</p>

<p>Maybe is a tool that fills the same gap as <code>null</code> but is much more helpful to programmers. It helps directly address the core problem of &#8220;people not properly reasoning about their functions&#8221; by pointing out mistakes in reasoning earlier. With it you can statically verify that all null checks are made, and eliminate an entire class of run-time errors.</p>

<p>I&#8217;m not claiming it is a silver bullet, but it <strong>is</strong> a better tool.</p>
<h4><a class='header_link' href='#default-value' id='default-value'>Null is meaningful! What if a value cannot have any meaningful default value?</a> </h4>
<p>Then either wait until it has a meaningful value to put in it or wrap it in Maybe and give it a value of Nothing. That&#8217;s what Maybe is for - To provide a type-checkable alternative to <code>null</code>!</p>
<h4><a class='header_link' href='#same-thing' id='same-thing'>So you're still testing against null, except that it's called Nothing. What have we gained?</a> </h4>
<p>We have gained earlier detection of an entire class of errors! Now if there is a missed check for an empty value you will find out at compile-time rather than run-time. Using Maybe forces you to be <em>explicit</em> about possibly-empty values and <em>deal with</em> the case where they are empty.</p>

<p>The user doesn&#8217;t see <strong>any</strong> null reference exceptions, they are all fixed before they even get outside the developer&#8217;s computer.</p>
<h4><a class='header_link' href='#safe navigation' id='safe navigation'>I think the safe navigation operator in Groovy/Kotlin/Fantom/CoffeeScript is better than Maybe.</a> </h4>
<p>I&#8217;m going to talk about Kotlin and Fantom separately in the next section because they&#8217;re special.</p>

<p>In Groovy/CoffeeScript, the safe navigation operator (<code>?.</code>) lets you safely call a method or access a field on an object that may be <code>null</code>. If the object IS <code>null</code> then the method/field just returns <code>null</code> as well, instead of an exception being thrown.</p>

<p>I agree that the safe navigation operator is certainly convenient but it is solving a different problem. If you compare it directly to Maybe, it&#8217;s only solving the &#8216;retrieve value from possibly empty object&#8217; part of Maybe. This is a nice thing to have, but isn&#8217;t nearly as interesting as moving a whole class of run-time exceptions to compile-time.</p>

<p>Which is fine, it doesn&#8217;t have to be as good as Maybe to still be useful. Just don&#8217;t misrepresent it as being anything more than <strong>a convenient syntax for null checks</strong>.</p>
<h4><a class='header_link' href='#fantom-kotlin' id='fantom-kotlin'>What about Fantom &amp; Kotlin?</a> </h4>
<p>Fantom and Kotlin are different because they are both languages that have non-nullable reference types and have built Maybe in as a language feature. In both languages (<a href='http://fantom.org/doc/docLang/TypeSystem.html#nullableTypes'>Fantom</a>, <a href='http://confluence.jetbrains.com/display/Kotlin/Null-safety'>Kotlin</a>), you can distinguish a reference that may hold <code>null</code> by appending a ? to its type (i.e. <code>String?</code>). The compiler can then keep track of it as if it were a <code>Maybe&lt;String&gt;</code> and is able to prevent you from unsafely accessing its contents. They provide safe navigation and elvis operators to extract the value like Groovy does.</p>

<p>This is probably where opinions will start to differ among people who think Maybe is a good idea.</p>

<p>I personally am thrilled by the steps Fantom and Kotlin have taken and think that they are a great solution to eliminating null reference exceptions. They use the fact that they&#8217;ve implemented it as a language feature to provide really convenient and easy to understand syntax. So easy to understand, in fact, that it might not be obvious that <strong>it is the same damn thing as Maybe</strong>. The only differences are that Fantom and Kotlin have a special syntax for it baked in, and that (in exchange) it is a little bit more limited than Maybe as a library is.</p>

<p>The only downsides to this approach are related to the fact that it is specialized. When you stretch against the limits of Maybe you can&#8217;t drop in <a href='http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Either.html'>Either</a> instead. You also can&#8217;t wrap Maybes in another Maybe (<code>Maybe&lt;Maybe&lt;String&gt;&gt;</code>), which you might do when you have nested calls that could fail.</p>

<p>I can&#8217;t speak to how often this ends up being an issue for people working in Fantom/Kotlin and what alternatives the language provides because, frankly, I am pretty unfamiliar with them. If anyone with experience would like to speak up I&#8217;d be happy to add their information to this section.</p>
<h4><a class='header_link' href='#option-scala' id='option-scala'>But Option in Scala DOESN'T save you from null!</a> </h4>
<p>Yes, in Scala you can still get NullPointerExceptions. Scala doesn&#8217;t have non-nullable reference types because Martin Odersky (for what were probably good reasons - I&#8217;m guessing related to java interop) decided to include <code>null</code> in his language. That doesn&#8217;t invalidate all the other implementations of Maybe and it doesn&#8217;t mean it can&#8217;t still be somewhat useful in Scala.</p>

<p>Feel free to point out to people that Scala&#8217;s implementation of Option still allows for NullPointerExceptions, just don&#8217;t generalize it to &#8220;Maybe and Option aren&#8217;t useful&#8221;.</p>
<h4><a class='header_link' href='#unsafe-methods' id='unsafe-methods'>Safety ISN'T guaranteed because of the existence of unsafe extraction methods.</a> </h4>
<p>Often implementations of Maybe will include more than just safe extraction methods. Haskell&#8217;s <code>fromJust</code> and Scala&#8217;s <code>get</code> are both retrieval functions that throw runtime errors if the value wrapped in Maybe doesn&#8217;t exist. Just like how <code>null</code> usually works.</p>

<p>So it <strong>is</strong> possible to shoot yourself in the foot if you want to. The difference is you have to <strong>explicitly ask</strong> for this behaviour, it cannot sneak in by accident.</p>

<p>Whenever I claim Maybe can move null reference exceptions to compile-time, it comes with the assumption that you&#8217;re using the built-in safe extraction methods and that you&#8217;re not <em>requesting</em> run-time exceptions.</p>
<h4><a class='header_link' href='#overhead' id='overhead'>Using Maybe is not worth the overhead.</a> </h4>
<p>This is a hard question to answer without getting specific. If this was said about a specific language or kind of application and the person saying it has done their due diligence or has some working code to back it up, then I can&#8217;t address that here.</p>

<p>If it is a less qualified statement however, I have some counterpoints that I can share.</p>

<p><strong>1. Bugs are expensive, even more so the later on they are caught.</strong></p>

<p>It takes developer time to find and fix bugs - the more bugs the more time it takes. For each bug, overhead is introduced in the form of finding, tracking, fixing, and testing it. Worse, bugs that make it all the way to production impact your users and can have even more expensive consequences like data corruption. For some applications small amounts of bug-related downtime could cost thousands (or millions!) of dollars.</p>

<p>This is the whole reason why we have test suites, type systems, static analysis tools, code reviews, even exceptions! We want to catch bugs earlier.</p>

<p>Maybe lets you catch one of the most common bugs, null reference exceptions, at compile-time instead of run-time. So if you say &#8216;it is not worth the overhead&#8217;, think about what null reference exceptions are costing you first, and make sure you really <strong>do</strong> know how much it is worth.</p>

<p><strong>Unless&#8230;</strong> you are one of those lucky few who says that null reference exceptions really are just not an issue for you. Maybe your other bug prevention measures combined are good enough and when you tracked your faults you found you don&#8217;t end up dealing with null reference exceptions very much. For you guys, keep in mind that <a href='https://twitter.com/ID_AA_Carmack/status/324998304045879296'>you are probably not in the majority</a>.</p>

<p><strong>2. There might not be as much syntactic overhead as you think. In many cases it actually reduces overhead.</strong></p>

<p>Languages that provide Maybe usually provide many convenient ways to extract values which are actually often shorter than the null checks you would otherwise be writing. On top of that, code that <em>doesn&#8217;t deal</em> with possibly-empty values <em>doesn&#8217;t need</em> to use Maybe (or check for null!) at all.</p>

<p>Check out the <a href='#examples'>examples section</a> below and see for yourself what code that uses Maybe looks like.</p>

<p>For those of you that are talking about having to mark too many properties as optional and having to deal with Maybe everywhere, think about it like this: You would have had to deal with the same amount of possibly-empty values either way, the only difference is that now you have the compiler helping you out. If your code is meant to be robust it will need null checks anyway. For the cost of adding a little wrapper around your types you can replace those easy-to-forget null checks with their equivalent compiler-checked Maybe extraction methods.</p>

<p>You also get perfect safety and ease of mind when dealing with values that cannot logically be empty.</p>
<h4><a class='header_link' href='#examples' id='examples'>Enough vague,
high-level information. Show me some examples!</a> </h4>
<p>I intentionally avoided showing examples in the explanation section to avoid taking attention away from the main points. For a topic like this one, as soon as you show some code it is like sticking a bikeshedding magnet right in the middle of your article. But since this post is aiming to be a definitive reference, it could use at least a few examples.</p>

<p>Another measure I am going to be taking to avoid stirring up unnecessary arguments is <em>comparing like with like</em>. I will show a scenario where null checks are used to deal with an empty value in a certain way, then I will show what that example would look like in a language with good support for Maybe.</p>

<p>The languages I picked are:</p>

<ul>
<li><strong>Java:</strong> to represent the traditional ways of handling nulls that most people are hopefully familiar with.</li>

<li><strong>Kotlin:</strong> to represent languages with non-nullable references and support for Maybe baked into the language.</li>

<li><strong>Haskell:</strong> to represent languages with non-nullable references and support for Maybe as a library.</li>
</ul>

<p>The scenarios follow:</p>

<p><strong>Dealing with it explicitly</strong></p>
<p class='code-header'>Java:</p><div class='highlight'><pre><code class='java'><span class='kd'>public</span> <span class='kd'>static</span> <span class='kt'>void</span> <span class='nf'>retrieveInfoExplicit</span><span class='o'>()</span> <span class='o'>{</span>
    <span class='n'>String</span> <span class='n'>information</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Random</span><span class='o'>().</span><span class='na'>nextInt</span><span class='o'>(</span><span class='mi'>2</span><span class='o'>)</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='o'>?</span> <span class='s'>&quot;a,b,c&quot;</span> <span class='o'>:</span> <span class='kc'>null</span><span class='o'>;</span>

    <span class='k'>if</span> <span class='o'>(</span><span class='n'>information</span> <span class='o'>==</span> <span class='kc'>null</span><span class='o'>)</span> <span class='o'>{</span>
        <span class='n'>System</span><span class='o'>.</span><span class='na'>out</span><span class='o'>.</span><span class='na'>println</span><span class='o'>(</span><span class='s'>&quot;No information received.&quot;</span><span class='o'>);</span>
    <span class='o'>}</span> <span class='k'>else</span> <span class='o'>{</span>
        <span class='n'>System</span><span class='o'>.</span><span class='na'>out</span><span class='o'>.</span><span class='na'>println</span><span class='o'>(</span><span class='n'>Arrays</span><span class='o'>.</span><span class='na'>toString</span><span class='o'>(</span><span class='n'>parseInfo</span><span class='o'>(</span><span class='n'>information</span><span class='o'>)));</span>
    <span class='o'>}</span>
<span class='o'>}</span>
</code></pre></div><p class='code-header'>Kotlin:</p><div class='highlight'><pre><code class='kotlin'><span class='k'>fun</span> <span class='nf'>retrieveInfoExplicit</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>Unit</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='n'>information</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>Random</span><span class='p'>().</span><span class='n'>nextInt</span><span class='p'>(</span><span class='m'>2</span><span class='p'>)</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='s'>&quot;a,b,c&quot;</span> <span class='k'>else</span> <span class='k'>null</span>

    <span class='k'>if</span> <span class='p'>(</span><span class='n'>information</span> <span class='p'>==</span> <span class='k'>null</span><span class='p'>)</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;No information received.&quot;</span><span class='p'>)</span>
    <span class='k'>else</span>
        <span class='nf'>safeParseInfo</span><span class='p'>(</span><span class='n'>information</span><span class='p'>)</span> <span class='n'>forEach</span> <span class='p'>{</span> <span class='n'>println</span><span class='p'>(</span><span class='n'>it</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>
</code></pre></div><p class='code-header'>Haskell:</p><div class='highlight'><pre><code class='haskell'><span class='nf'>retrieveInfoExplicit</span> <span class='ow'>::</span> <span class='kt'>IO</span> <span class='nb'>()</span>
<span class='nf'>retrieveInfoExplicit</span> <span class='ow'>=</span> <span class='kr'>do</span>
    <span class='n'>num</span> <span class='ow'>&lt;-</span> <span class='n'>randomRIO</span> <span class='p'>(</span><span class='mi'>0</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>)</span>
    <span class='kr'>let</span> <span class='n'>information</span> <span class='ow'>=</span> <span class='kr'>if</span> <span class='p'>(</span><span class='n'>num</span> <span class='ow'>::</span> <span class='kt'>Int</span><span class='p'>)</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='kr'>then</span> <span class='p'>(</span><span class='kt'>Just</span> <span class='s'>&quot;a,b,c&quot;</span><span class='p'>)</span> <span class='kr'>else</span> <span class='kt'>Nothing</span>
    <span class='kr'>case</span> <span class='n'>information</span> <span class='kr'>of</span>
        <span class='kt'>Nothing</span> <span class='ow'>-&gt;</span> <span class='n'>putStrLn</span> <span class='s'>&quot;No information retrieved.&quot;</span>
        <span class='kt'>Just</span> <span class='n'>i</span> <span class='ow'>-&gt;</span> <span class='n'>putStrLn</span> <span class='o'>$</span> <span class='n'>show</span> <span class='o'>$</span> <span class='n'>safeParseInfo</span> <span class='n'>i</span>
</code></pre></div>
<p><strong>Dealing with it implicitly</strong></p>
<p class='code-header'>Java:</p><div class='highlight'><pre><code class='java'><span class='kd'>public</span> <span class='kt'>void</span> <span class='nf'>retrieveInfo</span><span class='o'>()</span> <span class='o'>{</span>
    <span class='n'>String</span> <span class='n'>information</span> <span class='o'>=</span> <span class='n'>Random</span><span class='o'>().</span><span class='na'>nextInt</span><span class='o'>(</span><span class='mi'>2</span><span class='o'>)</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='o'>?</span> <span class='s'>&quot;a,b,c&quot;</span> <span class='o'>:</span> <span class='kc'>null</span>
    <span class='n'>parseInfo</span><span class='o'>(</span><span class='n'>information</span><span class='o'>);</span>
<span class='o'>}</span>
</code></pre></div><p class='code-header'>Kotlin:</p><div class='highlight'><pre><code class='kotlin'><span class='k'>fun</span> <span class='nf'>retrieveInfo</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>Unit</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='n'>information</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>Random</span><span class='p'>().</span><span class='n'>nextInt</span><span class='p'>(</span><span class='m'>2</span><span class='p'>)</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='s'>&quot;a,b,c&quot;</span> <span class='k'>else</span> <span class='k'>null</span>
    <span class='n'>parseInfo</span><span class='p'>(</span><span class='n'>information</span><span class='p'>)?.</span><span class='n'>forEach</span> <span class='p'>{</span> <span class='n'>println</span><span class='p'>(</span><span class='n'>it</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>
</code></pre></div><p class='code-header'>Haskell:</p><div class='highlight'><pre><code class='haskell'><span class='nf'>retrieveInfo</span> <span class='ow'>::</span> <span class='kt'>IO</span> <span class='nb'>()</span>
<span class='nf'>retrieveInfo</span> <span class='ow'>=</span> <span class='kr'>do</span>
    <span class='n'>num</span> <span class='ow'>&lt;-</span> <span class='n'>randomRIO</span> <span class='p'>(</span><span class='mi'>0</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>)</span>
    <span class='kr'>let</span> <span class='n'>information</span> <span class='ow'>=</span> <span class='kr'>if</span> <span class='p'>(</span><span class='n'>num</span> <span class='ow'>::</span> <span class='kt'>Int</span><span class='p'>)</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='kr'>then</span> <span class='p'>(</span><span class='kt'>Just</span> <span class='s'>&quot;a,b,c&quot;</span><span class='p'>)</span> <span class='kr'>else</span> <span class='kt'>Nothing</span>
    <span class='n'>putStrLn</span> <span class='o'>$</span> <span class='n'>show</span> <span class='o'>$</span> <span class='n'>parseInfo</span> <span class='n'>information</span>
</code></pre></div>
<p><strong>Returning null as well (e.g. guard statements)</strong></p>
<p class='code-header'>Java:</p><div class='highlight'><pre><code class='java'><span class='kd'>public</span> <span class='n'>String</span><span class='o'>[]</span> <span class='nf'>parseInfo</span><span class='o'>(</span><span class='n'>String</span> <span class='n'>information</span><span class='o'>)</span> <span class='o'>{</span>
    <span class='k'>if</span> <span class='o'>(</span><span class='n'>information</span> <span class='o'>==</span> <span class='kc'>null</span><span class='o'>)</span> <span class='o'>{</span>
        <span class='k'>return</span> <span class='kc'>null</span><span class='o'>;</span>
    <span class='o'>}</span>

    <span class='k'>return</span> <span class='n'>information</span><span class='o'>.</span><span class='na'>split</span><span class='o'>(</span><span class='s'>&quot;,&quot;</span><span class='o'>);</span>
<span class='o'>}</span>
</code></pre></div><p class='code-header'>Kotlin:</p><div class='highlight'><pre><code class='kotlin'><span class='c1'>// Can choose to imitate java...</span>
<span class='k'>fun</span> <span class='nf'>parseInfo</span><span class='p'>(</span><span class='n'>information</span> <span class='p'>:</span> <span class='n'>String</span><span class='p'>?)</span> <span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;?</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>information</span> <span class='p'>==</span> <span class='k'>null</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>return</span> <span class='k'>null</span>
    <span class='p'>}</span>

    <span class='k'>return</span> <span class='n'>information</span><span class='p'>.</span><span class='n'>split</span><span class='p'>(</span><span class='s'>&quot;,&quot;</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='c1'>// ...Or take advantage of the safe navigation operator</span>
<span class='k'>fun</span> <span class='nf'>parseInfo</span><span class='p'>(</span><span class='n'>information</span> <span class='p'>:</span> <span class='n'>String</span><span class='p'>?)</span> <span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;?</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='n'>information</span><span class='p'>?.</span><span class='n'>split</span><span class='p'>(</span><span class='s'>&quot;,&quot;</span><span class='p'>)</span>
<span class='p'>}</span>
</code></pre></div><p class='code-header'>Haskell:</p><div class='highlight'><pre><code class='haskell'><span class='c1'>-- Can do it with pattern matching...</span>
<span class='nf'>parseInfo</span> <span class='ow'>::</span> <span class='kt'>Maybe</span> <span class='kt'>String</span> <span class='ow'>-&gt;</span> <span class='kt'>Maybe</span> <span class='p'>[</span><span class='kt'>String</span><span class='p'>]</span>
<span class='nf'>parseInfo</span> <span class='kt'>Nothing</span> <span class='ow'>=</span> <span class='kt'>Nothing</span>
<span class='nf'>parseInfo</span> <span class='p'>(</span><span class='kt'>Just</span> <span class='n'>information</span><span class='p'>)</span> <span class='ow'>=</span> <span class='kt'>Just</span> <span class='p'>(</span><span class='n'>splitOn</span> <span class='s'>&quot;,&quot;</span> <span class='n'>information</span><span class='p'>)</span>

<span class='c1'>-- ...Or with do notation...</span>
<span class='nf'>parseInfo</span> <span class='ow'>::</span> <span class='kt'>Maybe</span> <span class='kt'>String</span> <span class='ow'>-&gt;</span> <span class='kt'>Maybe</span> <span class='p'>[</span><span class='kt'>String</span><span class='p'>]</span>
<span class='nf'>parseInfo</span> <span class='n'>information</span> <span class='ow'>=</span> <span class='kr'>do</span> <span class='n'>i</span> <span class='ow'>&lt;-</span> <span class='n'>information</span>
                            <span class='kt'>Just</span> <span class='p'>(</span><span class='n'>splitOn</span> <span class='s'>&quot;,&quot;</span> <span class='n'>i</span><span class='p'>)</span>

<span class='c1'>-- ...Or with fmap</span>
<span class='nf'>parseInfo</span> <span class='ow'>::</span> <span class='kt'>Maybe</span> <span class='kt'>String</span> <span class='ow'>-&gt;</span> <span class='kt'>Maybe</span> <span class='p'>[</span><span class='kt'>String</span><span class='p'>]</span>
<span class='nf'>parseInfo</span> <span class='n'>information</span> <span class='ow'>=</span> <span class='n'>fmap</span> <span class='p'>(</span><span class='n'>splitOn</span> <span class='s'>&quot;,&quot;</span><span class='p'>)</span> <span class='n'>information</span>
</code></pre></div><!-- **Executing several operations that could fail in a row** -->
<p><strong>Giving something a default value</strong></p>
<p class='code-header'>Java:</p><div class='highlight'><pre><code class='java'><span class='n'>String</span> <span class='n'>name</span> <span class='o'>=</span> <span class='o'>(</span><span class='n'>author</span> <span class='o'>==</span> <span class='kc'>null</span><span class='o'>)</span> <span class='o'>?</span> <span class='s'>&quot;Anonymous&quot;</span> <span class='o'>:</span> <span class='n'>author</span><span class='o'>;</span>
</code></pre></div><p class='code-header'>Kotlin:</p><div class='highlight'><pre><code class='kotlin'><span class='k'>val</span> <span class='n'>name</span> <span class='p'>=</span> <span class='n'>author</span> <span class='p'>?:</span> <span class='s'>&quot;Anonymous&quot;</span>
</code></pre></div><p class='code-header'>Haskell:</p><div class='highlight'><pre><code class='haskell'><span class='kr'>let</span> <span class='n'>name</span> <span class='ow'>=</span> <span class='n'>fromMaybe</span> <span class='s'>&quot;Anonymous&quot;</span> <span class='n'>author</span>
</code></pre></div>
<p><strong>Throwing an exception</strong></p>
<p class='code-header'>Java:</p><div class='highlight'><pre><code class='java'><span class='kd'>public</span> <span class='n'>String</span><span class='o'>[]</span> <span class='nf'>parseInfo</span><span class='o'>(</span><span class='n'>String</span> <span class='n'>information</span><span class='o'>)</span> <span class='o'>{</span>
    <span class='k'>return</span> <span class='n'>information</span><span class='o'>.</span><span class='na'>split</span><span class='o'>(</span><span class='s'>&quot;,&quot;</span><span class='o'>);</span>
<span class='o'>}</span>
</code></pre></div><p class='code-header'>Kotlin:</p><div class='highlight'><pre><code class='kotlin'><span class='k'>fun</span> <span class='nf'>parseInfo</span><span class='p'>(</span><span class='n'>information</span> <span class='p'>:</span> <span class='n'>String</span><span class='p'>?)</span> <span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='n'>information</span><span class='p'>!!.</span><span class='n'>split</span><span class='p'>(</span><span class='s'>&quot;,&quot;</span><span class='p'>)</span>
<span class='p'>}</span>
</code></pre></div><p class='code-header'>Haskell:</p><div class='highlight'><pre><code class='haskell'><span class='nf'>parseInfo</span> <span class='ow'>::</span> <span class='kt'>Maybe</span> <span class='kt'>String</span> <span class='ow'>-&gt;</span> <span class='kt'>Maybe</span> <span class='p'>[</span><span class='kt'>String</span><span class='p'>]</span>
<span class='nf'>parseInfo</span> <span class='n'>information</span> <span class='ow'>=</span> <span class='kt'>Just</span> <span class='p'>(</span><span class='n'>splitOn</span> <span class='s'>&quot;,&quot;</span> <span class='p'>(</span><span class='n'>fromJust</span> <span class='n'>information</span><span class='p'>))</span>
</code></pre></div>
<p><strong>Not having to check for null</strong></p>

<p>Java: Does not have this option, you always have to deal with null.</p>
<p class='code-header'>Kotlin:</p><div class='highlight'><pre><code class='kotlin'><span class='c1'>// note: no ? appended to types</span>
<span class='k'>fun</span> <span class='nf'>safeParseInfo</span><span class='p'>(</span><span class='n'>information</span> <span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='n'>information</span><span class='p'>.</span><span class='n'>split</span><span class='p'>(</span><span class='s'>&quot;,&quot;</span><span class='p'>)</span>
<span class='p'>}</span>
</code></pre></div><p class='code-header'>Haskell:</p><div class='highlight'><pre><code class='haskell'><span class='c1'>-- and these types are not wrapped in Maybe</span>
<span class='nf'>safeParseInfo</span> <span class='ow'>::</span> <span class='kt'>String</span> <span class='ow'>-&gt;</span> <span class='p'>[</span><span class='kt'>String</span><span class='p'>]</span>
<span class='nf'>safeParseInfo</span> <span class='n'>information</span> <span class='ow'>=</span> <span class='n'>splitOn</span> <span class='s'>&quot;,&quot;</span> <span class='n'>information</span>
</code></pre></div>
<p>The nice thing about this last example is that if the code changes and this function now needs to be called with a value that might be <code>null</code>, the code won&#8217;t compile until the developer has revisited <code>safeParseInfo</code> and explicitly chosen to deal with <code>null</code> in one of the ways shown above.</p>

<p>In case you want to run the examples yourself:</p>

<ul>
<li>The Java examples import <code>java.util.Arrays</code> and <code>java.util.Random</code></li>

<li>The Kotlin examples import <code>java.util.Random</code></li>

<li>The Haskell examples import <code>System.Random</code>, <code>Data.List.Split</code>, and <code>Data.Maybe</code></li>
</ul>

<p>That&#8217;s it, that&#8217;s the end of both the <a href='#faq'>FAQ</a> and this article. Hope you enjoyed it!</p>
</div>


<div id="socialbuttons">
<div>
    <div id="rss_button"><a href="http://feeds.feedburner.com/NickKnowlson"><img src="/img/feed-icon-28x28.png">&nbsp;</a></div>
    <!-- G+ -->
    <div id="google_plus_button"><g:plusone></g:plusone>
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script></div>

    <!-- Twitter -->
    <div id="twitter_button"><a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="nickknw">Tweet</a>
    <script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
    <script type="text/javascript" charset="utf-8">
      window.twttr = (function (d,s,id) {
        var t, js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return; js=d.createElement(s); js.id=id;
        js.src="//platform.twitter.com/widgets.js"; fjs.parentNode.insertBefore(js, fjs);
        return window.twttr || (t = { _e: [], ready: function(f){ t._e.push(f) } });
      }(document, "script", "twitter-wjs"));
    </script>
    </div>
    <!-- Reddit -->
    <div id="reddit_button"><script type="text/javascript" src="http://www.reddit.com/static/button/button1.js"></script></div>

    <!-- Facebook -->
    <div id="facebook_button"><div id="fb-root"></div> <script src="http://connect.facebook.net/en_US/all.js#appId=122515937846861&amp;xfbml=1"></script><fb:like href="http://nickknowlson.com/blog/2013/04/16/why-maybe-is-better-than-null/" send="false" layout="button_count" width="320" show_faces="true" action="like" font=""></fb:like></div>

    <script type="text/javascript">
    var _gaq = _gaq || [];

    if (FB && FB.Event && FB.Event.subscribe) {
        FB.Event.subscribe('edge.create', function(targetUrl) {
          _gaq.push(['_trackSocial', 'facebook', 'like', targetUrl]);
        });
    }

    $(document).ready(function () {
        if( twttr && twttr.events && twttr.events.bind) {
            twttr.events.bind('tweet', function(event) {
                _gaq.push(['_trackSocial', 'twitter', 'tweet', document.URL]);
            });
        }
    });
    </script>
</div>
</div>


<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'nickknowlson'; // required: replace example with your forum shortname

    var disqus_identifier = '/blog/2013/04/16/why-maybe-is-better-than-null';
    var disqus_url = 'http://nickknowlson.com//blog/2013/04/16/why-maybe-is-better-than-null/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


            </div>
        </div>
        <div id="footer">&copy; Copyright 2013 Nick Knowlson</div>
        <div style="display: none;">Content by Nick Knowlson: <a href="https://plus.google.com/104462106474002996122?rel=author" rel="me">Google+</a></div>
        <!--hacky way of reducing image loading lag when hovering over rss and
            twitter icons for now --><span style="display: none;"><img src="/img/rss-icon-lit.png" alt="rss" /><img src="/img/twitter-icon-lit.png" alt="twitter" /></span>
    <!-- HitTail Code -->
    <script type="text/javascript">
            (function(){ var ht = document.createElement('script');ht.async = true;
              ht.type='text/javascript';ht.src = '//103757.hittail.com/mlt.js';
              var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ht, s);})();
    </script>
    </body>
</html>
