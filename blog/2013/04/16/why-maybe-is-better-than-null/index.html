<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
    <head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
        <meta name="description" content="Maybe, at its core, is a construct that allows programmers to move null checks into the type system, so they can be enforced at compile-time.">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:url" content="http://nickknowlson.com/blog/2013/04/16/why-maybe-is-better-than-null/">
        <meta name="twitter:title" content="The Definitive Reference To Why Maybe Is Better Than Null">
        <meta name="twitter:description" content="Maybe, at its core, is a construct that allows programmers to move null checks into the type system, so they can be enforced at compile-time.">
        <meta name="twitter:image" content="http://nickknowlson.com/img/logos/logox50.png">
        <meta name="twitter:site" content="@nickknw">

        <meta property="og:title" content="The Definitive Reference To Why Maybe Is Better Than Null" >
        <meta property="og:type" content="article" >
        <meta property="og:image" content="http://nickknowlson.com/img/logos/logox200.png" >
        <meta property="og:url" content="http://nickknowlson.com/blog/2013/04/16/why-maybe-is-better-than-null/">
        <meta property="og:site_name" content="Nick Knowlson dot com">
        <meta property="og:description" content="Maybe, at its core, is a construct that allows programmers to move null checks into the type system, so they can be enforced at compile-time.">
        <meta property="fb:admins" content="717055264" />

        <title>The Definitive Reference To Why Maybe Is Better Than Null - Nick Knowlson</title>

        <link rel="stylesheet" type="text/css" href="/css/site.css" >
        <link rel="stylesheet" type="text/css" href="/css/syntax.css" >
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon-precomposed" href="/favicon.ico" >
        <link href="http://feeds.feedburner.com/NickKnowlson" type="application/atom+xml" rel="alternate" title="Blog ATOM Feed" />
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js" type="text/javascript"></script>
        <script type="text/javascript">
        if (typeof jQuery == 'undefined')
        {
            document.write(decodeURIComponent("%3Cscript src='/js/jquery-1.6.1.min.js' type='text/javascript'%3E%3C/script%3E"));
        }
        </script>
        

        
        <script type="text/javascript">
        // TODO: convert to css hover sometime
        $(document).ready(function () {
            $("#rss-nav-icon img").hover(function () {
                $(this).attr("src","/img/rss-icon-lit.png");
            }, function() {
                $(this).attr("src","/img/rss-icon-dim.png");
            });
            $("#twitter-nav-icon img").hover(function () {
                $(this).attr("src","/img/twitter-icon-lit.png");
            }, function() {
                $(this).attr("src","/img/twitter-icon-dim.png");
            });
        });
        </script>

        <!-- Google Analytics -->
        <script type="text/javascript">
          var _gaq = _gaq || [];

          if (document.location.hostname !== "localhost") {
              _gaq.push(['_setAccount', 'UA-24781362-1']);
              _gaq.push(['_trackPageview']);

              (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
              })();
          }
        </script>
    </head>
    <body>
	<div id="header" class="grid grid-16">
            <a href="/"><img src="/img/logos/logo6.png" alt="logo" /></a>
            <ul id="nav">
                <li><a class=" nav-link" href="/">Home</a></li>
                <li><a class=" nav-link" href="/about/">About</a></li>
                <li><a class=" nav-link" href="/projects/">Projects</a></li>
                <li><a class="selected nav-link" href="/blog/">Blog</a></li>
                <li><a class=" nav-link" href="/contact/">Contact</a></li>
                <li><a id="rss-nav-icon" href="http://feeds.feedburner.com/NickKnowlson"><img src="/img/rss-icon-dim.png" alt="link to feedburner rss" /></a></li>
                <li><a id="twitter-nav-icon" href="http://twitter.com/#!/nickknw"><img src="/img/twitter-icon-dim.png" alt="link to twitter" /></a></li>
            </ul>
	</div>

        <div id="content" class="grid grid-16" style="background-color:white; clear:both;">
            <div id="content-padding">
                <a href="/blog/archive/">&laquo; Back to posts</a>
<h1 style="margin:0px;;">The Definitive Reference To Why Maybe Is Better Than Null</h1>
<div class="faded" style="font-size:14px; margin-bottom:5px;">16 Apr 2013</div>
<div id="post">
<p>This article is divided into two parts: explanation and FAQ. The explanation explains why there are a lot of people who think the idea behind Maybe is way more useful than <code>null</code>. The FAQ is mostly a list of my responses to common arguments I&#8217;ve seen about the shortcomings of Maybe.</p>

<p>I&#8217;m going to try to not go overboard with details here - my aim with this explanation is to make it accessible to as many programmers as possible, not to be as thorough as possible.</p>

<h2 id='explanation'>Explanation</h2>
<h3>Motivation</h3>
<p>Tony Hoare, the inventor of <code>null</code>, <a href='http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake'>has gone on record calling it his &#8216;billion-dollar mistake&#8217;</a>. So what should replace it?</p>

<p>Maybe, at its core, is a construct that allows programmers to <strong>move null checks into the type system</strong>, so they can be enforced at <em>compile-time</em>. Instead of forgetting to deal with a null check and finding out with an exception at run-time, you forget to deal with a null check and <em>find out at compile-time,</em> before anyone else even sees it! And that&#8217;s <strong>not just some null checks</strong>, that&#8217;s <strong>all of them, guaranteed!</strong></p>
<h3>Details</h3>
<p>There are two components to an environment free of null pointer exceptions:</p>

<ol>
<li>The elimination of <code>null</code>. This means that all types (even reference types!) become non-nullable.</li>

<li>An alternative representation for the idea of &#8220;may contain an empty or invalid value&#8221;. This is what Maybe is for.</li>
</ol>

<p>So how does Maybe accomplish this, and how does it achieve all those benefits listed above? It&#8217;s actually very straightforward.</p>

<p>In object-oriented terms, think of <code>Maybe</code> as a generic interface that has exactly two implementing classes: <code>Just</code> and <code>Nothing</code>. The <code>Just</code> class wraps a value of some other type and the <code>Nothing</code> class doesn&#8217;t. There are a variety of ways to extract the value safely, but I&#8217;m going to omit these for now, as they&#8217;re not the point. When you receive an object of type <code>Maybe&lt;String&gt;</code> (for example) you now have the type system helping you out, telling you &#8220;there <em>might</em> be a String here but it <em>might</em> be empty&#8221;. You <strong>can&#8217;t</strong> perform operations on the String until you&#8217;ve safely extracted it and <em>made a choice</em> about what to do in the case that its empty.</p>

<p>By itself (without point <strong>#1</strong>) this is nice but not fantastic. The benefit really kicks in when you also have non-nullable types. It simplifies the 80% of the cases that don&#8217;t involve <code>null</code> and gives significance and meaning to the times when you do deal with objects wrapped in <code>Maybe&lt;T&gt;</code>. It lets you say both &#8220;I know that this value will <em>literally never</em> be null&#8221; and &#8220;It is immediately obvious to me that I need to handle the case of an empty value here&#8221;.</p>
<h3>Conclusion</h3>
<p>It&#8217;s not that dealing with any given instance of null is particularly hard, it&#8217;s that it is <a href='http://james-iry.blogspot.ca/2013/03/king-null-stubborn.html'>so easy to miss one</a>. Removing this concern and encoding the information in the type system means programmers have less things to keep track of and simplifies control flow across the entire program. Like with memory management: when you don&#8217;t have to keep track of it manually it is just plain easier to write code. More importantly, it is easier to write <strong>more robust</strong> code. For all programmers, not just the experienced or talented.</p>

<p>And that is something I am firmly in favour of. A product is rarely built by a single person. Improvements to other people&#8217;s code benefit all of us.</p>
<h3>Addendum</h3>
<p>There are two more points I&#8217;d like to address about Maybe that are separate from actually explaining why it is useful.</p>

<p><strong>First</strong>, I&#8217;ve been a bit inaccurate on purpose when just referring to this idea as Maybe. There is an implementation of this idea in Haskell called Maybe, but implementations in different languages have different names.</p>

<ul>
<li>ML, Scala, F#, Rust: Option</li>

<li>C#: Nullable</li>

<li>Fantom, Kotlin: ? appended to type</li>
</ul>

<p><strong>Second</strong>, not all environments with Maybe have non-nullable types. This makes Maybe less valuable in those environments (since you lose the <strong>very</strong> useful &#8220;I know this value will never contain <code>null</code>&#8221; guarantee&#8221;) and ends up confusing people who are skeptical of Maybe&#8217;s benefits.</p>

<p>To help clarify this: I agree that in a language where you don&#8217;t have the guarantee provided by non-nullable types, Maybe <em>just isn&#8217;t as useful</em>. But it is not use_less_ either and depending on the environment may still provide some benefit.</p>

<h2 id='faq'>FAQ</h2>

<p>Posts like these are tricky. To explain something understandably and (relatively) concisely I can&#8217;t qualify every statement and address all the holes inline. Here is where I&#8217;ll address the bits I skipped as well as some common sentiments I&#8217;ve previously seen on this topic.</p>

<p>I have made each headline a link as well so each question/answer combo can be linked to individually.</p>

<ol>
<li><a href='#maybe-shortcomings'>Maybe isn&#8217;t the be-all end-all.</a></li>

<li><a href='#ide-plugin'>My IDE plugin already does this.</a></li>

<li><a href='#hiding'>NPEs are the proper response to a missing value you forgot to consider.</a></li>

<li><a href='#real-problem'>The real problem is people not properly reasoning about their functions.</a></li>

<li><a href='#default-value'>What if a value cannot have any meaningful default value?</a></li>

<li><a href='#same-thing'>So you&#8217;re still testing against null, except that it&#8217;s called Nothing.</a></li>

<li><a href='#safe-invoke'>I think the safe-invoke operator in Groovy etc. is better than Maybe.</a></li>

<li><a href='#fantom-kotlin'>What About Fantom &#38; Kotlin?</a></li>

<li><a href='#option-scala'>But Option in Scala DOESN&#8217;T save you from null!</a></li>

<li><a href='#unsafe-methods'>Safety ISN&#8217;T guaranteed because of the existence of unsafe extraction methods.</a></li>
</ol>
<h4><a class='header_link' href='#maybe-shortcomings' id='maybe-shortcomings'>Maybe isn't the be-all
end-all.</a> </h4>
<p>I definitely agree. For one thing, I haven&#8217;t even mentioned <a href='http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Either.html'>Either</a>! This article is for people who aren&#8217;t convinced of the benefits of Maybe yet. In order to get my point across effectively I want to avoid overwhelming the reader with information, so I restricted the topics brought up here.</p>

<p>If you want a higher level perspective on this issue, take a look at <a href='http://lambda-the-ultimate.org/node/3186#comment-46637'>dmbarbour&#8217;s view:</a></p>
<blockquote>
<p>There are two mistakes. One mistake is providing a 'sum' type (eqv. to Just
Object | Nothing) without recognition of the typechecker. The other mistake
is joining this sum type at the hip with the idea of references, such that
you cannot have one without the other.</p>

<p>These mistakes may, and I suspect should, be resolved independently.
Thinking there's just one mistake, and thus just one language feature to
solve it, might very well be a third mistake.</p>
</blockquote>
<p>Beautifully stated! This is a much more general (and elegant) way to look at it. It&#8217;s a somewhat harder sentiment to communicate effectively to a lot of people though.</p>
<h4><a class='header_link' href='#ide-plugin' id='ide-plugin'>My IDE plugin already does this.</a> </h4>
<p>Yes, there are some IDEs and plugins that provide limited null reference analysis. The key though, is that it <strong>is</strong> limited. As far as I know none of them provide the same system-wide elimination of <code>null</code> that encoding it in the type-system can guarantee.</p>

<p>And so, you still don&#8217;t get the same reassurances of &#8220;I know this value will <em>literally never</em> be null&#8221; and &#8220;It is immediately obvious that I have to handle the case of an empty value here&#8221;.</p>
<h4><a class='header_link' href='#hiding' id='hiding'>NPEs are the proper
response to a missing value you forgot to consider. You should be notified when
something goes wrong, not hide it with Maybe.</a> </h4>
<p>I&#8217;ve got good news for you - we fundamentally agree in our approach to how errors should be handled! You have probably seen some bad examples of Maybe usage, since proper usage would lead to these errors being caught <em>even earlier</em> than a NullPointerException would have.</p>

<p>Buggy code is instead caught at compile-time and your program ends up not <em>having</em> to throw an exception and terminate gracefully because <em>the bug has already been fixed!</em></p>
<h4><a class='header_link' href='#real-problem' id='real-problem'>The real
problem is people not properly reasoning about their functions, that isn't the
fault of null.</a> </h4>
<p>Sure, that is one way to look at it: it&#8217;s not <code>null</code>&#8217;s fault, it is the programmer&#8217;s fault. If you take this view then <code>null</code> is just one of the tools used to represent emptiness and invalid values. But it isn&#8217;t a very good tool, or at least not as good as it could be.</p>

<p>Maybe is a tool that fills the same gap as <code>null</code> but is much more helpful to programmers. It helps directly address the core problem of &#8220;people not properly reasoning about their functions&#8221; by pointing out mistakes in reasoning earlier. With it you can statically verify that all null checks are made, and eliminate an entire class of run-time errors.</p>

<p>I&#8217;m not claiming it is a silver bullet, but it <strong>is</strong> a better tool.</p>
<h4><a class='header_link' href='#default-value' id='default-value'>Null is meaningful! What if a value cannot have any meaningful default value?</a> </h4>
<p>Then either wait until it has a meaningful value to put in it or wrap it in Maybe and give it a value of Nothing. That&#8217;s what Maybe is for - To provide a type-checkable alternative to <code>null</code>!</p>
<h4><a class='header_link' href='#same-thing' id='same-thing'>So you're still testing against null, except that it's called Nothing. What have we gained?</a> </h4>
<p>We have gained earlier detection of an entire class of errors! Now if there is a missed check for an empty value you will find out at compile-time rather than run-time. The user doesn&#8217;t see the error, it is fixed before it gets outside the developer&#8217;s computer.</p>
<h4><a class='header_link' href='#safe-invoke' id='safe-invoke'>I think the safe-invoke operator in Groovy/Kotlin/Fantom/CoffeeScript is better than Maybe.</a> </h4>
<p>I&#8217;m going to talk about Kotlin and Fantom separately in the next section because they&#8217;re special.</p>

<p>In Groovy/CoffeeScript, the safe invoke operator (<code>?.</code>) lets you safely call a method or access a field on an object that may be <code>null</code>. If the object IS <code>null</code> then the method/field just returns <code>null</code> as well, instead of an exception being thrown.</p>

<p>I agree that the safe-invoke operator is certainly convenient but it is solving a different problem. If you compare it directly to Maybe, it&#8217;s only solving the &#8216;retrieve value from possibly empty object&#8217; part of Maybe. This is a nice thing to have, but isn&#8217;t nearly as interesting as moving a whole class of run-time exceptions to compile-time.</p>

<p>Which is fine, <a href='http://james-iry.blogspot.ca/2009/07/groovy-does-not-have-optional-static.html'>Groovy isn&#8217;t really about statically enforcing things</a> and neither is CoffeeScript. Just don&#8217;t misrepresent this feature as being anything more than <strong>a convenient syntax for null checks</strong>.</p>
<h4><a class='header_link' href='#fantom-kotlin' id='fantom-kotlin'>What About Fantom &amp; Kotlin?</a> </h4>
<p>Fantom and Kotlin are different because they are both languages that have non-nullable reference types and have built Maybe in as a language feature. In both languages (<a href='http://fantom.org/doc/docLang/TypeSystem.html#nullableTypes'>Fantom</a>, <a href='http://confluence.jetbrains.com/display/Kotlin/Null-safety'>Kotlin</a>), you can distinguish a reference that may hold <code>null</code> by appending a ? to its type (i.e. <code>String?</code>). The compiler can then keep track of it as if it were a <code>Maybe&lt;String&gt;</code> and is able to prevent you from unsafely accessing its contents. They provide safe-invoke and elvis operators to extract the value like Groovy does.</p>

<p>This is probably where opinions will start to differ among people who think Maybe is a good idea.</p>

<p>I personally am thrilled by the steps Fantom and Kotlin have taken and think that they are a great solution to eliminating null reference exceptions. They use the fact that they&#8217;ve implemented it as a language feature to provide really convenient and easy to understand syntax. So easy to understand, in fact, that it might not be obvious that <strong>it is the same damn thing as Maybe</strong>. The only differences are that Fantom and Kotlin have a special syntax for it baked in, and that (in exchange) it is a little bit more limited than Maybe as a library is.</p>

<p>The only downsides to this approach are related to the fact that it is specialized. When you stretch against the limits of Maybe you can&#8217;t drop in <a href='http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Either.html'>Either</a> instead. You also can&#8217;t wrap Maybes in another Maybe (<code>Maybe&lt;Maybe&lt;String&gt;&gt;</code>), which you might do when you have nested calls that could fail.</p>

<p>I can&#8217;t speak to how often this ends up being an issue for people working in Fantom/Kotlin and what alternatives the language provides because, frankly, I am pretty unfamiliar with them. If anyone with experience would like to speak up I&#8217;d be happy to annotate this section with their information.</p>
<h4><a class='header_link' href='#option-scala' id='option-scala'>But Option in Scala DOESN'T save you from null!</a> </h4>
<p>Yes, in Scala you can still get NullPointerExceptions. Scala doesn&#8217;t have non-nullable reference types because Martin Odersky (for what were probably good reasons - I&#8217;m guessing related to java interop) decided to include <code>null</code> in his language. That doesn&#8217;t invalidate all the other implementations of Maybe and it doesn&#8217;t mean it can&#8217;t still be somewhat useful in Scala.</p>

<p>Feel free to point out to people that Scala&#8217;s implementation of Option still allows for NullPointerExceptions, just don&#8217;t generalize it to &#8220;Maybe and Option aren&#8217;t useful&#8221;.</p>
<h4><a class='header_link' href='#unsafe-methods' id='unsafe-methods'>Safety ISN'T guaranteed because of the existence of unsafe extraction methods.</a> </h4>
<p>Often implementations of Maybe will include more than just safe extraction methods. Haskell&#8217;s <code>fromJust</code> and Scala&#8217;s <code>get</code> are both retrieval functions that throw runtime errors if the value wrapped in Maybe doesn&#8217;t exist. Just like how <code>null</code> usually works.</p>

<p>So it <strong>is</strong> possible to shoot yourself in the foot if you want to. The difference is: you have to <strong>explicitly ask</strong> for this behaviour, it cannot sneak in by accident.</p>

<p>Whenever I claim Maybe can move null reference exceptions to compile-time, it comes with the assumption that you&#8217;re using the built-in safe extraction methods and that you&#8217;re not <em>requesting</em> run-time exceptions.</p>
</div>


<div id="socialbuttons">
<div>
    <div id="rss_button"><a href="http://feeds.feedburner.com/NickKnowlson"><img src="/img/feed-icon-28x28.png">&nbsp;</a></div>
    <!-- G+ -->
    <div id="google_plus_button"><g:plusone></g:plusone>
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script></div>

    <!-- Twitter -->
    <div id="twitter_button"><a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="nickknw">Tweet</a>
    <script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
    <script type="text/javascript" charset="utf-8">
      window.twttr = (function (d,s,id) {
        var t, js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return; js=d.createElement(s); js.id=id;
        js.src="//platform.twitter.com/widgets.js"; fjs.parentNode.insertBefore(js, fjs);
        return window.twttr || (t = { _e: [], ready: function(f){ t._e.push(f) } });
      }(document, "script", "twitter-wjs"));
    </script>
    </div>
    <!-- Reddit -->
    <div id="reddit_button"><script type="text/javascript" src="http://www.reddit.com/static/button/button1.js"></script></div>

    <!-- Facebook -->
    <div id="facebook_button"><div id="fb-root"></div> <script src="http://connect.facebook.net/en_US/all.js#appId=122515937846861&amp;xfbml=1"></script><fb:like href="http://nickknowlson.com/blog/2013/04/16/why-maybe-is-better-than-null/" send="false" layout="button_count" width="320" show_faces="true" action="like" font=""></fb:like></div>

    <script type="text/javascript">
    var _gaq = _gaq || [];

    if (FB && FB.Event && FB.Event.subscribe) {
        FB.Event.subscribe('edge.create', function(targetUrl) {
          _gaq.push(['_trackSocial', 'facebook', 'like', targetUrl]);
        });
    }

    $(document).ready(function () {
        if( twttr && twttr.events && twttr.events.bind) {
            twttr.events.bind('tweet', function(event) {
                _gaq.push(['_trackSocial', 'twitter', 'tweet', document.URL]);
            });
        }
    });
    </script>
</div>
</div>


<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'nickknowlson'; // required: replace example with your forum shortname

    var disqus_identifier = '/blog/2013/04/16/why-maybe-is-better-than-null';
    var disqus_url = 'http://nickknowlson.com//blog/2013/04/16/why-maybe-is-better-than-null/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


            </div>
        </div>
        <div id="footer">&copy; Copyright 2013 Nick Knowlson</div>
        <div style="display: none;">Content by Nick Knowlson: <a href="https://plus.google.com/104462106474002996122?rel=author" rel="me">Google+</a></div>
        <!--hacky way of reducing image loading lag when hovering over rss and
            twitter icons for now --><span style="display: none;"><img src="/img/rss-icon-lit.png" alt="rss" /><img src="/img/twitter-icon-lit.png" alt="twitter" /></span>
    <!-- HitTail Code -->
    <script type="text/javascript">
            (function(){ var ht = document.createElement('script');ht.async = true;
              ht.type='text/javascript';ht.src = '//103757.hittail.com/mlt.js';
              var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ht, s);})();
    </script>
    </body>
</html>
